Exercise: Equivalent Binary Trees
=================================

葉に保持されている値が同じ順序をもつ、多くの種類のバイナリツリーがあります。 例えば、ここに"1, 1, 2, 3, 5, 8, 13"を保持する２つのバイナリツリーがあります。

![](http://go-tour-jp.appspot.com/static/tree.png)

２つのバイナリツリーが同じ順序で保持しているかどうかを確認する機能は、多くの他の言語でとても複雑です。 私たちは簡単な解決法を記述するために、Goの並行性( concurrency )とチャネルを利用してみます。

この例は、型を以下のように定義する tree パッケージを利用します。

```go
type Tree struct {
    Left  *Tree
    Value int
    Right *Tree
}
```

**1**. Walk 関数を実装してみてください。

**2**. 関数をテストしてみてください。

関数 tree.New(k) は、値( k, 2k, 3k, ..., 10k )をもつ、ランダムに構造化されたバイナリツリーを生成します。

新しいチャネル ch を生成し、 Walk をはじめてみましょう。

```go
go Walk(tree.New(1), ch)
```
そして、そのチャネルから読み出し、10個の値を表示してみてください。 それは、 1, 2, 3, ..., 10 という表示になるでしょう。

**3**. t1 と t2 が同じ値を保存しているどうかを判断するため、 Walk を使って、 Same 関数を実装してみてください。

**4**. Same 関数をテストしてみてください。

Same(tree.New(1), tree.New(1)) は、 true を返す必要があります。 また、 Same(tree.New(1), tree.New(2)) は、 false を返す必要があります。
